// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity ^0.8.0;


import "@openzeppelin/contracts/access/Ownable.sol";

contract Graphic is Ownable {


    // Audio Fles Contract:

    // File number: 1 
    // Title: Breaking the Chain
    // Album: Living an Impossible Dream
    // Website: https://QuantumIndigo.org
    // IPFS URL: (IPFS URL)
    // Comment: The World's First Decentralised Media Arts Collective.
    // Copyright: 2020 QMP (GnuPG ID FFE28038)
    // Submission Date: [DD.MM.YY]
    // Blockchain Write Date: [UNIX Date Generated by Smart Contract]
    // MD5 Hash: [MD5_hash]

    struct FileOutput {
		string separator;
        string file_number;
		string title;
		string album;
		string website;
		string ipfs_hash;
		string comment;
		string copyright;
        string submission_date;
		string blockchain_date;
        string md_hash;
    }

    struct FileOutputCollection {
        bytes32[] file_number;
		bytes32[] title;
		bytes32[] album;
		bytes32[] website;
		bytes32[] comment;
		bytes32[] copyright;
        bytes32[] md_hash;
        bytes32[] ipfs_hash_part1;
        bytes32[] ipfs_hash_part2;
        bytes8[] separator;
        bytes8[] submission_date;
		bytes8[] blockchain_date;
    }

    uint256 private size;

	// Searches will be done nased on IPFS hash and SHA256 Hash.

    mapping(uint256 => bytes32) filesNumberIndex;
    mapping(bytes32 => uint256[]) filesByNumber;

    mapping(uint256 => bytes32[2]) filesIpfsHashIndex;
    mapping(bytes32 => uint256[]) filesByIpfsHash;

	mapping(uint256 => bytes32) filesMDHashIndex;
    mapping(bytes32 => uint256[]) filesByMDHash;

  
	mapping(uint256 => bytes32) filesTitleIndex;
    mapping(uint256 => bytes32) filesAlbumSeriesIndex;
	mapping(uint256 => bytes32) filesWebsiteIndex;
	mapping(uint256 => bytes32) filesCommentIndex;
	mapping(uint256 => bytes32) filesCopyrightIndex;
    mapping(uint256 => bytes8) filesSubmissionDateIndex;
	mapping(uint256 => bytes8) filesBlockchainDateIndex;
    
    constructor() {
        size = 0;
    }

    function addFile(string[] memory metadata) public onlyOwner returns (uint256) {

        require( metadata.length == 9);

		// Data is pasted in FileOutput Order. Blockchain date is skipped because it will be added when the block is mined.
		// 8 Items in total

        bytes32 _file_number = dataConvert(metadata[0]);
        bytes32 _title = dataConvert(metadata[1]);
        bytes32 _album = dataConvert(metadata[2]);
        bytes32 _website = dataConvert(metadata[3]);
        (bytes32 _part1, bytes32 _part2) = splitIpfsHash(bytes(metadata[4]));
	    // string memory _ipfs_hash = metadata[4];
        bytes32 _comment = dataConvert(metadata[5]);
		bytes32 _copyright = dataConvert(metadata[6]);
        bytes8 _submission_date = dataConvert8(metadata[7]);
		bytes32 _md_hash = dataConvert(metadata[8]);
 

        filesNumberIndex[size] = _file_number;
        filesTitleIndex[size] = _title;
        filesAlbumSeriesIndex[size] = _album;
        filesWebsiteIndex[size] = _website;
        // filesIpfsHashIndex[size] = _ipfs_hash;
        filesIpfsHashIndex[size][0] = _part1;
        filesIpfsHashIndex[size][1] = _part2;
        filesCommentIndex[size] = _comment;
        filesCopyrightIndex[size] = _copyright;
        filesSubmissionDateIndex[size] = _submission_date;
		

        (uint year, uint month, uint day) = timestampToDate(block.timestamp);
        filesBlockchainDateIndex[size] = dataConvert8(concat( convertVaalue(day),  ".",  convertVaalue(month), ".", convertVaalue(year) ));

        filesMDHashIndex[size] = _md_hash;


        filesByNumber[_file_number].push(size);
        bytes32 _hashId = keccak256(abi.encodePacked(metadata[4]));
        filesByIpfsHash[_hashId].push(size);
        filesByMDHash[_md_hash].push(size);

        size = size + 1;
        return size;
    }

    function Find_Files_by_QI_Audio_Catalogue_Number(string calldata QI_Audio_Catalogue) view external returns (FileOutput[] memory) {
        return findFilesByKey(1, QI_Audio_Catalogue);
    }

    function Find_Files_by_IPFS_Hash(string calldata IPFS_Hash) view external returns (FileOutput[] memory) {
        return findFilesByKey(2, IPFS_Hash);
    }

    function Find_Files_by_MD5_Hash(string calldata MD5_Hash) view external returns (FileOutput[] memory) {
        return findFilesByKey(3, MD5_Hash);
    }

    function findFilesByKey(int key, string memory hash) view internal returns (FileOutput[] memory) {
        uint256 len;


        if(key == 1){
            len = filesByNumber[dataConvert(hash)].length;
        } 

        if(key == 2){
            bytes32 _hashId = keccak256(abi.encodePacked(hash));
            len = filesByIpfsHash[_hashId].length;
        } 

        if(key == 3){
            len = filesByMDHash[dataConvert(hash)].length;
        } 

        FileOutputCollection memory outputsCollection;

        outputsCollection.separator = new bytes8[](len);
        outputsCollection.file_number = new bytes32[](len);
        outputsCollection.title = new bytes32[](len);
        outputsCollection.album = new bytes32[](len);
        outputsCollection.website = new bytes32[](len);
        // outputsCollection.ipfs_hash = new string[](len);
        // outputsCollection.ipfs_hash = new bytes32[2][](len);
        outputsCollection.ipfs_hash_part1 = new bytes32[](len);
        outputsCollection.ipfs_hash_part2 = new bytes32[](len);
        outputsCollection.comment = new bytes32[](len);
        outputsCollection.copyright = new bytes32[](len);
        outputsCollection.submission_date = new bytes8[](len);
        outputsCollection.blockchain_date = new bytes8[](len);	
		outputsCollection.md_hash = new bytes32[](len);	

        for (uint256 index = 0; index < len; index++){
            uint256 id;

            if(key == 1){
                id = filesByNumber[dataConvert(hash)][index];
            } 

            if(key == 2){
                bytes32 __hashId = keccak256(abi.encodePacked(hash));
                id = filesByIpfsHash[__hashId][index];
            } 

            if(key == 3){
                id = filesByMDHash[dataConvert(hash)][index];
            } 


            outputsCollection.file_number[index] = filesNumberIndex[id];
            outputsCollection.title[index] = filesTitleIndex[id];
            outputsCollection.album[index] = filesAlbumSeriesIndex[id];
            outputsCollection.website[index] = filesWebsiteIndex[id];
            // outputsCollection.ipfs_hash[index] = filesIpfsHashIndex[id];
            outputsCollection.ipfs_hash_part1[index] = filesIpfsHashIndex[id][0];
            outputsCollection.ipfs_hash_part2[index] = filesIpfsHashIndex[id][1];
            outputsCollection.comment[index] = filesCommentIndex[id];
            outputsCollection.copyright[index] = filesCopyrightIndex[id];
            outputsCollection.submission_date[index] = filesSubmissionDateIndex[id];
            outputsCollection.blockchain_date[index] =  filesBlockchainDateIndex[id];
			outputsCollection.md_hash[index] = filesMDHashIndex[id];	

        }

        
		FileOutput[] memory outputs = new FileOutput[](len);
		for (uint256 index = 0; index < len; index++) {

            FileOutput memory output;

            output = FileOutput(
                "****",
                concat("File Number: ", string(abi.encodePacked(outputsCollection.file_number[index]))),
                concat("Title: ", string(abi.encodePacked(outputsCollection.title[index]))),
                concat("Series: ", string(abi.encodePacked(outputsCollection.album[index]))),
                concat("Website: ", string(abi.encodePacked(outputsCollection.website[index]))),
                concat("IPFS URL: https://ipfs.io/ipfs/", concatpfsHash(outputsCollection.ipfs_hash_part1[index], outputsCollection.ipfs_hash_part2[index])),
                concat("Comment: ", string(abi.encodePacked(outputsCollection.comment[index]))),
                concat("Copyright: ", string(abi.encodePacked(outputsCollection.copyright[index]))),
                concat("Submission Date: ", string(abi.encodePacked(outputsCollection.submission_date[index]))),
                concat("Blockchain Write Date: ", string(abi.encodePacked(outputsCollection.blockchain_date[index]))),
                concat("MD5 Hash: ", string(abi.encodePacked(outputsCollection.md_hash[index])))
            );

			outputs[index] = output;
		}
		return outputs;

	}

    function splitIpfsHash(bytes memory _ipfsHash) private pure returns (bytes32 _part1, bytes32 _part2){
        require(_ipfsHash.length>=32);
        bytes memory _temp1 = new bytes(32);
        for(uint i=0;i<32;i++){
            _temp1[i] = _ipfsHash[i];
        }
        assembly {
            _part1 := mload(add(_temp1, 32))
        }
        bytes memory _temp2 = new bytes(32);
        for(uint i=32;i<_ipfsHash.length;i++){
            _temp2[i-32] = _ipfsHash[i];
        }
        assembly {
            _part2 := mload(add(_temp2, 32))
        }
    }

    
    function concatpfsHash(bytes32  _part1, bytes32 _part2) private pure returns (string memory){
        bytes memory _ipfsHash = new bytes(64);
        assembly {
            mstore(add(_ipfsHash, 32), _part1)
            mstore(add(_ipfsHash, 64), _part2)
        }
        return string(_ipfsHash);
    }

	function concat(string memory a, string memory b) private pure returns (string memory) {
		return string(abi.encodePacked(a, b));
	}

    
	function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {
        (year, month, day) = daysToDate(timestamp / (24 * 60 * 60));
    }


    function convertVaalue(uint _value) internal pure returns (string memory value) {
        if( _value <10) {
            value = concat("0", uint2str(_value));
        } else {
            value = uint2str(_value);
        }
    }

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }

    function daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {
        int __days = int(_days);

        int L = __days + 68569 + 2440588;
        int N = 4 * L / 146097;
        L = L - (146097 * N + 3) / 4;
        int _year = 4000 * (L + 1) / 1461001;
        L = L - 1461 * _year / 4 + 31;
        int _month = 80 * L / 2447;
        int _day = L - 2447 * _month / 80;
        L = _month / 11;
        _month = _month + 2 - 12 * L;
        _year = 100 * (N - 49) + _year + L;
        _year = _year % 100;

        year = uint(_year);
        month = uint(_month);
        day = uint(_day);
    }

	function concat(string memory a, string memory b, string memory c, string memory d, string memory e) private pure returns (string memory) {
		return string(abi.encodePacked(a, b, c, d, e));
	}

    function dataConvert(string memory _str) private pure returns (bytes32 _value){
        bytes memory _temp = bytes(_str);
        require(_temp.length<=32);
        bytes memory __temp = new bytes(32);
        for(uint i=0;i<_temp.length;i++){
            __temp[i] = _temp[i];
        }
        assembly {
            _value := mload(add(__temp, 32))
        }
    }

    function dataConvert8(string memory _str) private pure returns (bytes8 _value){
        bytes memory _temp = bytes(_str);
        require(_temp.length<=8);
        bytes memory __temp = new bytes(8);
        for(uint i=0;i<_temp.length;i++){
            __temp[i] = _temp[i];
        }
        assembly {
            _value := mload(add(__temp, 32))
        }
    }

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

